import boto3
import base64
import anthropic
import os
import json
import re

def get_classification_prompt(company_name):
    """Create classification prompt with payroll document detection"""
    
    # Generate company name variations for better matching
    company_variations = generate_company_variations(company_name)
    
    return f"""You are a highly accurate document classification AI assistant. Perform strict OCR analysis on the uploaded document and extract key information in the specified JSON format.

**CRITICAL OUTPUT REQUIREMENT:**
Your response MUST contain ONLY valid JSON. Absolutely NO markdown, NO code blocks, NO explanations, NO comments.
Do NOT wrap your response in ```json or ``` tags.
Do NOT add any text before or after the JSON.
Start directly with {{ and end with }}.
Output pure JSON only.

**USER'S COMPANY:** "{company_name}"

🚨🚨🚨 **PERSPECTIVE RULE - READ THIS FIRST** 🚨🚨🚨

ALL classifications MUST be from {company_name}'s perspective ONLY.
NEVER classify from the document issuer's perspective.
NEVER classify from a third-party perspective.

If the document was sent TO {company_name} → They must pay → BILL
If the document was sent BY {company_name} → They will be paid → INVOICE

**COMPANY NAME MATCHING:**
Match ANY of these variations (case-insensitive):
{company_variations}

═══════════════════════════════════════════════════════════════════════════════
**CLASSIFICATION ALGORITHM - FOLLOW EXACTLY IN THIS ORDER**
═══════════════════════════════════════════════════════════════════════════════

**STEP 1: DOCUMENT TYPE IDENTIFICATION**

Analyze the document structure carefully and identify which type it belongs to. Each document type has SPECIFIC characteristics that must ALL be present.

═══════════════════════════════════════════════════════════════════════════════
**A. PAYROLL DOCUMENT CHECK**
═══════════════════════════════════════════════════════════════════════════════

A document is PAYROLL if it shows employee salary/wage information for the company's own employees.

**MANDATORY PAYROLL CHARACTERISTICS (need 5+ to confirm):**

1. ✓ Document title explicitly contains: "PAYROLL", "PAYROLL ANALYSIS", "PAYROLL REPORT", "SALARY REGISTER", "WAGE SHEET", "PAYSLIP", "EMPLOYEE COMPENSATION"

2. ✓ Document is FOR the company ({company_name}), not TO the company
   - Header shows: "PAYROLL ANALYSIS REPORT FOR COMPANY: {company_name}"
   - NOT "INVOICE TO: {company_name}" from an external vendor

3. ✓ Contains employee-specific fields:
   - Employee ID/Code (e.g., U8003, EMP001, etc.)
   - Employee Name
   - Department/Designation

4. ✓ Period/Month specified (payroll cycle):
   - "202506 - JUNE", "PERIOD: JUNE 2025", "Month: June"
   - Payroll period dates

5. ✓ Salary/Earnings breakdown columns present (3+ of these):
   - SALARY, BASE PAY, GROSS PAY, BASIC SALARY
   - BONUS, OVERTIME, ALLOWANCES
   - TRAVELING, ANNUAL LEAVE PAY

6. ✓ Deductions breakdown columns present (2+ of these):
   - DEDUCTIONS, ADVANCES, LOAN REPAYMENT
   - INCOME TAX, TDS, TAX DEDUCTED
   - PROVIDENT FUND (PF), ESI, SOCIAL INSURANCE
   - PROFESSIONAL TAX, CESS

7. ✓ Net pay or total earnings calculation:
   - NET PAY, TAKE HOME, TOTAL EARNINGS
   - Total after deductions

8. ✓ Company cost/employer contributions mentioned:
   - EMPLOYER PF, EMPLOYER ESI
   - COMPANY COST, TOTAL COMPANY COST
   - Employer contributions

9. ✓ Structured in salary calculation format:
   - Shows: Earnings + Additions - Deductions = Net Pay
   - OR: Gross columns → Deduction columns → Net columns

10. ✓ Internal document characteristics:
    - Generated BY the company for their own records
    - Not a bill/invoice FROM an external party
    - Footer may show internal payroll software (e.g., "INPayroll ©Soft Limited")

**CRITICAL: Payroll vs HR Vendor Invoice Distinction**

PAYROLL (internal document):
- Header: "PAYROLL REPORT FOR {company_name}"
- Shows: Individual employee breakdowns
- Purpose: Company's own salary processing
- Issued BY: {company_name}'s internal HR/payroll system
→ Classification: payroll + money_going_out

HR VENDOR INVOICE (external bill):
- Header: "INVOICE FROM: XYZ HR Services Pvt Ltd"
- TO/BILL TO: {company_name}
- Shows: Service charges for payroll processing
- Purpose: Vendor charging for their services
- Bank account: Vendor's account for payment
→ Classification: bill + money_going_out

**PAYROLL DECISION:**
- If 5+ indicators match → document_type = "payroll", category = "money_going_out"
- If fewer indicators → Continue to check other document types

═══════════════════════════════════════════════════════════════════════════════

═══════════════════════════════════════════════════════════════════════════════
**B. SHARE DOCUMENT CHECK**
═══════════════════════════════════════════════════════════════════════════════

A document is SHARE_DOCUMENT if it relates to company ownership, equity, or stock.

**MANDATORY SHARE DOCUMENT CHARACTERISTICS (need 3+ to confirm):**

1. ✓ Document title contains:
   - "SHARE CERTIFICATE", "STOCK CERTIFICATE"
   - "EQUITY ALLOCATION", "ESOP GRANT"
   - "SHAREHOLDER AGREEMENT", "SHAREHOLDING PATTERN"
   - "DIVIDEND DECLARATION", "DIVIDEND WARRANT"

2. ✓ Contains equity-specific terms:
   - Number of shares
   - Share class (equity, preference, common stock)
   - Share price or valuation
   - Shareholder name

3. ✓ Legal/regulatory markers:
   - Certificate number
   - Company registration details
   - Board resolution references
   - Distinctive numbers of shares

4. ✓ Ownership transfer or allocation language:
   - "Hereby certifies that..."
   - "Entitled to ... shares"
   - "Transfer of shares"

**SHARE DOCUMENT DECISION:**
- If 3+ indicators match → document_type = "share_document", category = "money_coming_in"
- If fewer indicators → Continue to check other document types

═══════════════════════════════════════════════════════════════════════════════

═══════════════════════════════════════════════════════════════════════════════
**C. BANK STATEMENT CHECK**
═══════════════════════════════════════════════════════════════════════════════

A document is BANK_STATEMENT if it shows banking transactions for an account.

**MANDATORY BANK STATEMENT CHARACTERISTICS (need 4+ to confirm):**

1. ✓ Document title contains:
   - "BANK STATEMENT", "ACCOUNT STATEMENT"
   - "STATEMENT OF ACCOUNT", "TRANSACTION HISTORY"

2. ✓ Bank branding and details:
   - Bank name and logo in header
   - Branch name/code
   - IFSC code or SWIFT code

3. ✓ Account information:
   - Account number
   - Account holder name
   - Account type (savings, current, etc.)

4. ✓ Transaction listing:
   - Date column for transactions
   - Debit/Credit or Withdrawal/Deposit columns
   - Running balance column
   - Transaction descriptions/references

5. ✓ Statement period:
   - "From [date] To [date]"
   - Opening balance and closing balance

6. ✓ Bank contact information:
   - Bank's registered address
   - Customer service numbers

**BANK STATEMENT DECISION:**
- If 4+ indicators match → document_type = "bank_statement", category = "bank_statement"
- If fewer indicators → Continue to check invoice/bill characteristics

═══════════════════════════════════════════════════════════════════════════════
**D. INVOICE / BILL DETERMINATION**
═══════════════════════════════════════════════════════════════════════════════

If the document is NOT payroll, share document, or bank statement, then it's either an INVOICE or BILL.
The distinction depends on WHO issued it and WHO must pay FROM {company_name}'S PERSPECTIVE.

🚨🚨🚨 **ABSOLUTE CLASSIFICATION RULES - FOLLOW IN EXACT ORDER** 🚨🚨🚨

═══════════════════════════════════════════════════════════════════════════════

**RULE 1: CHECK "TO:" / "BILL TO:" / "CUSTOMER:" FIELD FIRST**

Look for these exact fields in the document:
- "TO:", "BILL TO:", "CUSTOMER:", "CLIENT:", "BUYER:", "RECEIVER:", "SOLD TO:", "SHIP TO:"

**Question: Does {company_name} (or its variations) appear in ANY of these fields?**

✅ **YES** → {company_name} is in the TO/BILL TO/CUSTOMER field
   
   **ABSOLUTE RULE:** 
   - {company_name} is the RECIPIENT/CUSTOMER
   - {company_name} MUST PAY this document
   - Another company issued this TO {company_name}
   
   **MANDATORY OUTPUT:**
   {{
     "document_type": "bill",
     "category": "money_going_out",
     "reasoning": "{company_name} appears in [TO/BILL TO/CUSTOMER] field. They are the recipient and must pay. This is a BILL."
   }}
   
   **⛔ STOP HERE. DO NOT CHECK OTHER RULES. OUTPUT IMMEDIATELY.**

❌ **NO** → {company_name} is NOT in the TO/BILL TO/CUSTOMER field
   → Continue to Rule 2

═══════════════════════════════════════════════════════════════════════════════

**RULE 2: CHECK DOCUMENT HEADER/ISSUER**

Look at the TOP/HEADER section of the document for:
- Company name in largest font at top
- Company logo position (top left/center)
- Fields: "FROM:", "VENDOR:", "SELLER:", "SERVICE PROVIDER:"
- Company's tax/registration numbers in header
- Company's address/contact info at top

**Question: Does {company_name} (or its variations) appear as the ISSUER/HEADER?**

✅ **YES** → {company_name} is in the header as issuer
   
   **AND verify:** Is there ANOTHER company name in the TO:/CUSTOMER: field?
   
   ✅ **YES** → Different company in customer field
      
      **ABSOLUTE RULE:**
      - {company_name} ISSUED this document
      - {company_name} is REQUESTING payment
      - {company_name} will RECEIVE money
      
      **MANDATORY OUTPUT:**
      {{
        "document_type": "invoice",
        "category": "money_coming_in",
        "reasoning": "{company_name} issued this document to [customer name]. They are requesting payment. This is an INVOICE."
      }}
      
      **⛔ STOP HERE. OUTPUT IMMEDIATELY.**
   
   ❌ **NO** → No other company in customer field or unclear
      → Continue to Rule 3

❌ **NO** → {company_name} is NOT the issuer
   → Continue to Rule 3

═══════════════════════════════════════════════════════════════════════════════

**RULE 3: CHECK BANK ACCOUNT OWNERSHIP**

Look at the PAYMENT DETAILS section (usually at bottom):
- "Pay to:", "Remit to:", "Payment details:", "Bank details:"
- Bank account holder name
- IBAN, Account number

**Question: Whose bank account is listed for payment?**

✅ **Bank account belongs to {company_name}**
   → {company_name} will RECEIVE the payment
   
   **MANDATORY OUTPUT:**
   {{
     "document_type": "invoice",
     "category": "money_coming_in",
     "reasoning": "Payment details show {company_name}'s bank account. They will receive payment. This is an INVOICE."
   }}
   
   **⛔ STOP HERE. OUTPUT IMMEDIATELY.**

✅ **Bank account belongs to ANOTHER company** (not {company_name})
   → {company_name} must PAY to that account
   
   **MANDATORY OUTPUT:**
   {{
     "document_type": "bill",
     "category": "money_going_out",
     "reasoning": "Payment details show [vendor name]'s bank account. {company_name} must pay to this account. This is a BILL."
   }}
   
   **⛔ STOP HERE. OUTPUT IMMEDIATELY.**

❌ **NO clear bank account or unclear**
   → Continue to Rule 4

═══════════════════════════════════════════════════════════════════════════════

**RULE 4: FINAL PAYMENT DIRECTION TEST**

Based on ALL available information, answer this question:

**"Will {company_name} SEND money or RECEIVE money in this transaction?"**

Analyze:
- Document layout and structure
- Company positions in the document
- Payment terms and conditions
- Any contextual clues

✅ **{company_name} will SEND/PAY money**
   {{
     "document_type": "bill",
     "category": "money_going_out",
     "reasoning": "Based on document structure, {company_name} must pay. This is a BILL."
   }}

✅ **{company_name} will RECEIVE/GET PAID money**
   {{
     "document_type": "invoice",
     "category": "money_coming_in",
     "reasoning": "Based on document structure, {company_name} will receive payment. This is an INVOICE."
   }}

❌ **Cannot determine payment direction**
   {{
     "document_type": null,
     "category": "illegible_document",
     "reasoning": "Cannot determine payment direction or document structure unclear."
   }}

═══════════════════════════════════════════════════════════════════════════════

🚨 **CRITICAL VALIDATION BEFORE OUTPUT** 🚨

Before generating final JSON, verify these ABSOLUTE RULES:

**FORBIDDEN COMBINATIONS - THESE ARE ALWAYS WRONG:**

❌ {company_name} in "BILL TO:" field + document_type = "invoice" → **WRONG!** Must be "bill"
❌ {company_name} in "BILL TO:" field + category = "money_coming_in" → **WRONG!** Must be "money_going_out"
❌ {company_name} in "CUSTOMER:" field + document_type = "invoice" → **WRONG!** Must be "bill"
❌ document_type = "bill" + category = "money_coming_in" → **WRONG!** Must be "money_going_out"
❌ document_type = "invoice" + category = "money_going_out" → **WRONG!** Must be "money_coming_in"
❌ document_type = "payroll" + category = "money_coming_in" → **WRONG!** Must be "money_going_out"
❌ document_type = "share_document" + category = "money_going_out" → **WRONG!** Must be "money_coming_in"

**REQUIRED COMBINATIONS - THESE ARE ALWAYS CORRECT:**

✅ document_type = "payroll" → category MUST BE "money_going_out"
✅ document_type = "invoice" → category MUST BE "money_coming_in"
✅ document_type = "bill" → category MUST BE "money_going_out"
✅ document_type = "share_document" → category MUST BE "money_coming_in"
✅ {company_name} in "BILL TO:" field → MUST BE document_type = "bill" + category = "money_going_out"
✅ {company_name} as issuer + other company in "BILL TO:" → MUST BE document_type = "invoice" + category = "money_coming_in"

═══════════════════════════════════════════════════════════════════════════════

**CLASSIFICATION EXAMPLES - STUDY THESE CAREFULLY**

═══════════════════════════════════════════════════════════════════════════════

**Example 1: Clear BILL case**
Document header: "ABC Consulting Services Ltd"
BILL TO: Kyrastel Enterprises Limited
Amount: $500
Payment to: ABC Consulting's bank account

**Analysis:**
- Kyrastel appears in "BILL TO:" field → **Rule 1 triggers**
- Kyrastel is the CUSTOMER/RECIPIENT
- Kyrastel must PAY ABC Consulting

**Output:**
{{
  "document_type": "bill",
  "category": "money_going_out",
  "company_name": "Kyrastel Enterprises Limited",
  "reasoning": "Kyrastel Enterprises Limited appears in BILL TO field. They are receiving this document from ABC Consulting and must pay. This is a BILL."
}}

═══════════════════════════════════════════════════════════════════════════════

**Example 2: Clear INVOICE case**
Document header: "Kyrastel Enterprises Limited"
BILL TO: XYZ Corporation
Amount: $1000
Payment to: Kyrastel's bank account

**Analysis:**
- Kyrastel in header as issuer → **Rule 2 checks**
- XYZ Corporation in "BILL TO:" field (different company)
- Kyrastel's bank account for payment
- Kyrastel will RECEIVE money

**Output:**
{{
  "document_type": "invoice",
  "category": "money_coming_in",
  "company_name": "Kyrastel Enterprises Limited",
  "reasoning": "Kyrastel Enterprises Limited issued this document to XYZ Corporation. Payment goes to Kyrastel's bank account. They will receive payment. This is an INVOICE."
}}

═══════════════════════════════════════════════════════════════════════════════

**Example 3: Vendor invoice (BILL) case**
Document header: "N.A MechEnergy Consulting Engineer"
BILL TO: Kyrastel Enterprises ltd
Services: Engineering consultation
Payment to: N.A MechEnergy's bank account (IBAN: CY71...)

**Analysis:**
- Kyrastel in "BILL TO:" field → **Rule 1 IMMEDIATELY triggers**
- N.A MechEnergy is the issuer/vendor
- Payment goes to N.A MechEnergy's account
- Kyrastel must PAY

**Output:**
{{
  "document_type": "bill",
  "category": "money_going_out",
  "company_name": "Kyrastel Enterprises Limited",
  "reasoning": "Kyrastel Enterprises ltd appears in BILL TO field. N.A MechEnergy issued this to Kyrastel. Payment goes to N.A MechEnergy's bank account. Kyrastel must pay. This is a BILL."
}}

**⚠️ WRONG Classification Example:**
{{
  "document_type": "invoice",
  "category": "money_coming_in",
  "reasoning": "...from the issuer's perspective, this is an invoice..."
}}
**Why this is WRONG:**
- ❌ Used issuer's perspective instead of {company_name}'s perspective
- ❌ Ignored Rule 1: {company_name} in BILL TO field
- ❌ Forbidden combination: company in BILL TO + invoice type

═══════════════════════════════════════════════════════════════════════════════

**DOCUMENT TYPES:**
- "payroll": Payroll report with employee salary information → money_going_out
- "share_document": Share/stock/equity documents → money_coming_in
- "invoice": {company_name} issued it, requesting payment → money_coming_in
- "bill": {company_name} received it, must pay vendor → money_going_out
- "bank_statement": Bank statement → bank_statement
- null: Illegible/cannot determine

**CATEGORIES:**
- "money_coming_in": {company_name} receives money (invoice, share_document)
- "money_going_out": {company_name} pays money (bill, payroll)
- "bank_statement": Bank statement
- "illegible_document": Cannot determine

═══════════════════════════════════════════════════════════════════════════════

**REQUIRED JSON OUTPUT FORMAT:**
{{
  "document_type": "payroll|invoice|bill|bank_statement|share_document|null",
  "category": "money_coming_in|money_going_out|bank_statement|illegible_document",
  "company_name": "{company_name}",
  "total_amount": 1250.00,
  "confidence_score": 0.95,
  "reasoning": "Clear explanation from {company_name}'s perspective"
}}

═══════════════════════════════════════════════════════════════════════════════

**FINAL REMINDERS:**

1. ✅ ALWAYS classify from {company_name}'s perspective
2. ✅ Follow rules in EXACT order (Rule 1 → Rule 2 → Rule 3 → Rule 4)
3. ✅ STOP immediately when a rule gives a definitive answer
4. ✅ If {company_name} in "BILL TO:" field → ALWAYS bill + money_going_out
5. ✅ Check forbidden combinations before outputting
6. ✅ Payroll → always money_going_out
7. ✅ Invoice → always money_coming_in
8. ✅ Bill → always money_going_out
9. ❌ NEVER use issuer's perspective
10. ❌ NEVER output explanatory text, only JSON
11. ❌ NEVER use markdown code blocks or backticks
12. ❌ NEVER add any text before or after the JSON object

Output pure JSON immediately. No formatting. No markdown. Just JSON."""

def generate_company_variations(company_name):
    """Generate common variations of company name for better matching"""
    variations = [company_name]
    
    # Remove common suffixes for matching
    suffixes = [
        ' Pvt Ltd', ' Private Limited', ' Pvt. Ltd.', ' Private Ltd',
        ' Ltd', ' Limited', ' LLC', ' Inc', ' Corp', ' Corporation',
        ' LLP', ' LP', ' PLC', ' Co.', ' Company', ' ENTERPRISES LIMITED',
        ' Enterprises Limited', ' ENTERPRISES LTD', ' Enterprises Ltd'
    ]
    
    name_without_suffix = company_name
    for suffix in suffixes:
        if company_name.upper().endswith(suffix.upper()):
            name_without_suffix = company_name[:len(company_name)-len(suffix)].strip()
            variations.append(name_without_suffix)
            break
    
    # Add common abbreviations
    if len(name_without_suffix.split()) > 1:
        words = name_without_suffix.split()
        acronym = ''.join([w[0].upper() for w in words if w])
        if len(acronym) > 1:
            variations.append(acronym)
    
    # Format variations as bullet list
    return '\n'.join([f"  - {var}" for var in set(variations)])

def clean_json_response(response_text):
    """
    Clean Claude's response to extract pure JSON
    Handles markdown code blocks, extra whitespace, and double braces
    """
    cleaned = response_text.strip()
    
    # Remove markdown code blocks (both ```json and ```)
    if cleaned.startswith("```"):
        # Find the first newline after the opening fence
        first_newline = cleaned.find('\n')
        if first_newline != -1:
            cleaned = cleaned[first_newline + 1:]
        else:
            # No newline found, remove the fence directly
            if cleaned.startswith("```json"):
                cleaned = cleaned[7:]
            elif cleaned.startswith("```"):
                cleaned = cleaned[3:]
    
    # Remove trailing code fence
    if cleaned.endswith("```"):
        cleaned = cleaned[:-3]
    
    # Remove double braces (sometimes Claude uses template syntax)
    cleaned = cleaned.replace("{{", "{").replace("}}", "}")
    
    # Strip again to remove any whitespace from fence removal
    cleaned = cleaned.strip()
    
    return cleaned

def download_from_s3(s3_key, bucket_name=None):
    """Download file from S3 using key"""
    try:
        if not bucket_name:
            bucket_name = os.getenv('S3_BUCKET_NAME', 'company-documents-2025')
        
        # Initialize S3 client
        aws_access_key = os.getenv('AWS_ACCESS_KEY_ID')
        aws_secret_key = os.getenv('AWS_SECRET_ACCESS_KEY')
        aws_region = os.getenv('AWS_REGION', 'eu-north-1')
        
        if aws_access_key and aws_secret_key:
            s3_client = boto3.client(
                's3',
                aws_access_key_id=aws_access_key,
                aws_secret_access_key=aws_secret_key,
                region_name=aws_region
            )
        else:
            s3_client = boto3.client('s3', region_name=aws_region)
        
        print(f"Downloading from bucket: {bucket_name}, key: {s3_key}")
        
        response = s3_client.get_object(Bucket=bucket_name, Key=s3_key)
        return response['Body'].read()
        
    except Exception as e:
        raise Exception(f"Error downloading from S3: {str(e)}")

def process_document_with_claude(pdf_content, company_name):
    """Process document with Claude and return classification"""
    try:
        # Initialize Anthropic client
        anthropic_client = anthropic.Anthropic(
            api_key=os.getenv('ANTHROPIC_API_KEY')
        )
        
        # Encode to base64
        pdf_base64 = base64.b64encode(pdf_content).decode('utf-8')
        
        # Get prompt
        prompt = get_classification_prompt(company_name)
        
        # Send to Claude
        message = anthropic_client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=2500,
            temperature=0,
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "document",
                            "source": {
                                "type": "base64",
                                "media_type": "application/pdf",
                                "data": pdf_base64
                            }
                        },
                        {
                            "type": "text",
                            "text": prompt
                        }
                    ]
                }
            ]
        )
        
        # Extract response
        response_text = message.content[0].text.strip()
        
        print(f"Token usage - Input: {message.usage.input_tokens}, Output: {message.usage.output_tokens}")
        
        return {
            "success": True,
            "classification": response_text,
            "token_usage": {
                "input_tokens": message.usage.input_tokens,
                "output_tokens": message.usage.output_tokens
            }
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }

def main(data):
    """
    Main function for document classification
    """
    try:
        # Validate required fields
        if 'company_name' not in data:
            return {
                "success": False,
                "error": "company_name is required"
            }
            
        if 's3_key' not in data:
            return {
                "success": False,
                "error": "s3_key is required"
            }
        
        company_name = data['company_name']
        s3_key = data['s3_key']
        bucket_name = data.get('bucket_name')
        
        print(f"Processing document for company: {company_name}, S3 key: {s3_key}")
        
        # Download PDF from S3
        pdf_content = download_from_s3(s3_key, bucket_name)
        print(f"Downloaded PDF, size: {len(pdf_content)} bytes")
        
        # Process with Claude
        result = process_document_with_claude(pdf_content, company_name)
        
        if result["success"]:
            try:
                # Parse Claude's JSON response with robust cleaning
                cleaned_response = clean_json_response(result["classification"])
                
                print(f"Cleaned response: {cleaned_response[:200]}...")  # Debug log
                
                classification_data = json.loads(cleaned_response)
                
                # CRITICAL: Post-processing validation and auto-correction
                validation_result = validate_and_correct_classification(
                    classification_data, 
                    company_name,
                    result["classification"]
                )
                
                if validation_result["corrected"]:
                    print(f"⚠️ AUTO-CORRECTED: {validation_result['correction_reason']}")
                    classification_data = validation_result["corrected_data"]
                
                if validation_result["warnings"]:
                    print(f"⚠️ Validation warnings: {validation_result['warnings']}")
                
                return {
                    "success": True,
                    "result": classification_data,
                    "metadata": {
                        "token_usage": result["token_usage"],
                        "s3_key": s3_key,
                        "company_name": company_name,
                        "validation": {
                            "corrected": validation_result["corrected"],
                            "correction_reason": validation_result.get("correction_reason"),
                            "warnings": validation_result.get("warnings")
                        }
                    }
                }
                
            except json.JSONDecodeError as e:
                return {
                    "success": False,
                    "error": f"Claude returned invalid JSON: {str(e)}",
                    "raw_response": result["classification"],
                    "cleaned_response": clean_json_response(result["classification"])
                }
        else:
            return {
                "success": False,
                "error": result["error"]
            }
            
    except Exception as e:
        print(f"Classification error: {str(e)}")
        return {
            "success": False,
            "error": f"Internal processing error: {str(e)}"
        }

def validate_and_correct_classification(classification_data, company_name, raw_response):
    """
    Validate classification and auto-correct obvious errors
    Returns dict with correction status and warnings
    """
    doc_type = classification_data.get("document_type")
    category = classification_data.get("category")
    reasoning = classification_data.get("reasoning", "").lower()
    
    corrected = False
    correction_reason = None
    warnings = []
    
    # CRITICAL CHECK 0: Payroll validation
    if doc_type == "payroll" and category != "money_going_out":
        classification_data["category"] = "money_going_out"
        classification_data["reasoning"] = "Auto-corrected: Payroll documents always represent money_going_out (company paying employees)"
        corrected = True
        correction_reason = "Payroll must be money_going_out"
    
    # Detect if reasoning mentions payroll but classified differently
    payroll_keywords = [
        "payroll", "salary register", "employee compensation", 
        "wage sheet", "salary analysis", "payroll report"
    ]
    
    is_payroll_in_reasoning = any(
        keyword in reasoning 
        for keyword in payroll_keywords
    )
    
    if is_payroll_in_reasoning and doc_type != "payroll":
        warnings.append("Reasoning mentions payroll but document type is not 'payroll'. Review recommended.")
    
    # CRITICAL CHECK 1: Detect reasoning contradictions
    # If reasoning says "must pay" or "customer" but classified as invoice
    customer_keywords = [
        "customer who must pay", f"{company_name.lower()}.*must pay", f"{company_name.lower()}.*customer",
        f"{company_name.lower()}.*receiver", f"{company_name.lower()}.*client", "receiving this invoice",
        f"{company_name.lower()}.*are the customer", "pay this invoice"
    ]
    
    is_customer_in_reasoning = any(
        re.search(pattern, reasoning, re.IGNORECASE) 
        for pattern in customer_keywords
    )
    
    if is_customer_in_reasoning and (doc_type == "invoice" or category == "money_coming_in"):
        # CRITICAL ERROR: Reasoning says customer but classified as invoice
        classification_data["document_type"] = "bill"
        classification_data["category"] = "money_going_out"
        classification_data["reasoning"] = (
            f"CORRECTED: {company_name} is the CUSTOMER/RECEIVER, "
            "therefore they must PAY. This is a bill, not an invoice."
        )
        corrected = True
        correction_reason = "Reasoning indicated customer role but was classified as invoice"
    
    # CRITICAL CHECK 2: Logical consistency rules
    if doc_type == "share_document" and category != "money_coming_in":
        classification_data["category"] = "money_coming_in"
        classification_data["reasoning"] = "Auto-corrected: Share documents always represent money_coming_in"
        corrected = True
        correction_reason = "Share document must be money_coming_in"
    
    if doc_type == "invoice" and category != "money_coming_in":
        classification_data["category"] = "money_coming_in"
        corrected = True
        correction_reason = "Invoice must be money_coming_in"
        warnings.append("Invoice was incorrectly categorized")
    
    if doc_type == "bill" and category != "money_going_out":
        classification_data["category"] = "money_going_out"
        corrected = True
        correction_reason = "Bill must be money_going_out"
        warnings.append("Bill was incorrectly categorized")
    
    # CRITICAL CHECK 3: Category-to-type consistency
    if category == "money_coming_in" and doc_type not in ["invoice", "share_document", "bank_statement"]:
        if doc_type == "bill":
            # This is a critical error - bill cannot be money_coming_in
            classification_data["category"] = "money_going_out"
            corrected = True
            correction_reason = "Bill cannot be money_coming_in, corrected to money_going_out"
        elif doc_type == "payroll":
            # CRITICAL: payroll can NEVER be money_coming_in
            classification_data["category"] = "money_going_out"
            corrected = True
            correction_reason = "Payroll can NEVER be money_coming_in"
        else:
            warnings.append(f"Inconsistent: category='money_coming_in' but document_type='{doc_type}'")
    
    if category == "money_going_out" and doc_type not in ["bill", "payroll", "bank_statement"]:
        if doc_type == "invoice":
            # Critical error - invoice cannot be money_going_out
            classification_data["category"] = "money_coming_in"
            corrected = True
            correction_reason = "Invoice cannot be money_going_out, corrected to money_coming_in"
        elif doc_type == "share_document":
            # CRITICAL: share_document can NEVER be money_going_out
            classification_data["category"] = "money_coming_in"
            corrected = True
            correction_reason = "Share document can NEVER be money_going_out"
        else:
            warnings.append(f"Inconsistent: category='money_going_out' but document_type='{doc_type}'")
    
    # Check confidence score
    confidence = classification_data.get("confidence_score", 1.0)
    if confidence < 0.6:
        warnings.append(f"Low confidence ({confidence}). Manual review recommended.")
    
    return {
        "corrected": corrected,
        "correction_reason": correction_reason,
        "warnings": " | ".join(warnings) if warnings else None,
        "corrected_data": classification_data if corrected else None
    }

def health_check():
    """Health check for the classification service"""
    try:
        required_vars = ['ANTHROPIC_API_KEY']
        missing_vars = [var for var in required_vars if not os.getenv(var)]
        
        if missing_vars:
            return {
                "healthy": False,
                "error": f"Missing environment variables: {', '.join(missing_vars)}"
            }
        
        return {
            "healthy": True,
            "service": "claude-document-classification",
            "version": "4.0-payroll-support",
            "supported_types": ["payroll", "invoice", "bill", "share_document", "bank_statement"],
            "anthropic_configured": bool(os.getenv('ANTHROPIC_API_KEY')),
            "aws_configured": bool(os.getenv('AWS_ACCESS_KEY_ID') and os.getenv('AWS_SECRET_ACCESS_KEY')),
            "s3_bucket": os.getenv('S3_BUCKET_NAME', 'company-documents-2025')
        }
        
    except Exception as e:
        return {
            "healthy": False,
            "error": str(e)
        }