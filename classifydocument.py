import boto3
import base64
import anthropic
import os
import json
import re

def get_classification_prompt(company_name):
    """Create classification prompt with payroll document detection"""
    
    # Generate company name variations for better matching
    company_variations = generate_company_variations(company_name)
    
    return f"""You are a highly accurate document classification AI assistant. Perform strict OCR analysis on the uploaded document and extract key information in the specified JSON format.

**CRITICAL OUTPUT REQUIREMENT:**
Your response MUST contain ONLY valid JSON. Absolutely NO markdown, NO code blocks, NO explanations, NO comments.
Do NOT wrap your response in ```json or ``` tags.
Do NOT add any text before or after the JSON.
Start directly with {{ and end with }}.
Output pure JSON only.

**USER'S COMPANY:** "{company_name}"

üö®üö®üö® **PERSPECTIVE RULE - READ THIS FIRST** üö®üö®üö®

ALL classifications MUST be from {company_name}'s perspective ONLY.
NEVER classify from the document issuer's perspective.
NEVER classify from a third-party perspective.

If the document was sent TO {company_name} ‚Üí They must pay ‚Üí BILL
If the document was sent BY {company_name} ‚Üí They will be paid ‚Üí INVOICE

**COMPANY NAME MATCHING:**
Match ANY of these variations (case-insensitive):
{company_variations}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
**CLASSIFICATION ALGORITHM - FOLLOW EXACTLY IN THIS ORDER**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**STEP 1: DOCUMENT TYPE IDENTIFICATION**

Analyze the document structure carefully and identify which type it belongs to. Each document type has SPECIFIC characteristics that must ALL be present.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
**A. PAYROLL DOCUMENT CHECK**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

A document is PAYROLL if it shows employee salary/wage information for the company's own employees.

**MANDATORY PAYROLL CHARACTERISTICS (need 5+ to confirm):**

1. ‚úì Document title explicitly contains: "PAYROLL", "PAYROLL ANALYSIS", "PAYROLL REPORT", "SALARY REGISTER", "WAGE SHEET", "PAYSLIP", "EMPLOYEE COMPENSATION"

2. ‚úì Document is FOR the company ({company_name}), not TO the company
   - Header shows: "PAYROLL ANALYSIS REPORT FOR COMPANY: {company_name}"
   - NOT "INVOICE TO: {company_name}" from an external vendor

3. ‚úì Contains employee-specific fields:
   - Employee ID/Code (e.g., U8003, EMP001, etc.)
   - Employee Name
   - Department/Designation

4. ‚úì Period/Month specified (payroll cycle):
   - "202506 - JUNE", "PERIOD: JUNE 2025", "Month: June"
   - Payroll period dates

5. ‚úì Salary/Earnings breakdown columns present (3+ of these):
   - SALARY, BASE PAY, GROSS PAY, BASIC SALARY
   - BONUS, OVERTIME, ALLOWANCES
   - TRAVELING, ANNUAL LEAVE PAY

6. ‚úì Deductions breakdown columns present (2+ of these):
   - DEDUCTIONS, ADVANCES, LOAN REPAYMENT
   - INCOME TAX, TDS, TAX DEDUCTED
   - PROVIDENT FUND (PF), ESI, SOCIAL INSURANCE
   - PROFESSIONAL TAX, CESS

7. ‚úì Net pay or total earnings calculation:
   - NET PAY, TAKE HOME, TOTAL EARNINGS
   - Total after deductions

8. ‚úì Company cost/employer contributions mentioned:
   - EMPLOYER PF, EMPLOYER ESI
   - COMPANY COST, TOTAL COMPANY COST
   - Employer contributions

9. ‚úì Structured in salary calculation format:
   - Shows: Earnings + Additions - Deductions = Net Pay
   - OR: Gross columns ‚Üí Deduction columns ‚Üí Net columns

10. ‚úì Internal document characteristics:
    - Generated BY the company for their own records
    - Not a bill/invoice FROM an external party
    - Footer may show internal payroll software (e.g., "INPayroll ¬©Soft Limited")

**CRITICAL: Payroll vs HR Vendor Invoice Distinction**

PAYROLL (internal document):
- Header: "PAYROLL REPORT FOR {company_name}"
- Shows: Individual employee breakdowns
- Purpose: Company's own salary processing
- Issued BY: {company_name}'s internal HR/payroll system
‚Üí Classification: payroll + money_going_out

HR VENDOR INVOICE (external bill):
- Header: "INVOICE FROM: XYZ HR Services Pvt Ltd"
- TO/BILL TO: {company_name}
- Shows: Service charges for payroll processing
- Purpose: Vendor charging for their services
- Bank account: Vendor's account for payment
‚Üí Classification: bill + money_going_out

**PAYROLL DECISION:**
- If 5+ indicators match ‚Üí document_type = "payroll", category = "money_going_out"
- If fewer indicators ‚Üí Continue to check other document types

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
**B. SHARE DOCUMENT CHECK**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

A document is SHARE_DOCUMENT if it relates to company ownership, equity, or stock.

**MANDATORY SHARE DOCUMENT CHARACTERISTICS (need 3+ to confirm):**

1. ‚úì Document title contains:
   - "SHARE CERTIFICATE", "STOCK CERTIFICATE"
   - "EQUITY ALLOCATION", "ESOP GRANT"
   - "SHAREHOLDER AGREEMENT", "SHAREHOLDING PATTERN"
   - "DIVIDEND DECLARATION", "DIVIDEND WARRANT"

2. ‚úì Contains equity-specific terms:
   - Number of shares
   - Share class (equity, preference, common stock)
   - Share price or valuation
   - Shareholder name

3. ‚úì Legal/regulatory markers:
   - Certificate number
   - Company registration details
   - Board resolution references
   - Distinctive numbers of shares

4. ‚úì Ownership transfer or allocation language:
   - "Hereby certifies that..."
   - "Entitled to ... shares"
   - "Transfer of shares"

**SHARE DOCUMENT DECISION:**
- If 3+ indicators match ‚Üí document_type = "share_document", category = "money_coming_in"
- If fewer indicators ‚Üí Continue to check other document types

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
**C. BANK STATEMENT CHECK**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

A document is BANK_STATEMENT if it shows banking transactions for an account.

**MANDATORY BANK STATEMENT CHARACTERISTICS (need 4+ to confirm):**

1. ‚úì Document title contains:
   - "BANK STATEMENT", "ACCOUNT STATEMENT"
   - "STATEMENT OF ACCOUNT", "TRANSACTION HISTORY"

2. ‚úì Bank branding and details:
   - Bank name and logo in header
   - Branch name/code
   - IFSC code or SWIFT code

3. ‚úì Account information:
   - Account number
   - Account holder name
   - Account type (savings, current, etc.)

4. ‚úì Transaction listing:
   - Date column for transactions
   - Debit/Credit or Withdrawal/Deposit columns
   - Running balance column
   - Transaction descriptions/references

5. ‚úì Statement period:
   - "From [date] To [date]"
   - Opening balance and closing balance

6. ‚úì Bank contact information:
   - Bank's registered address
   - Customer service numbers

**BANK STATEMENT DECISION:**
- If 4+ indicators match ‚Üí document_type = "bank_statement", category = "bank_statement"
- If fewer indicators ‚Üí Continue to check invoice/bill characteristics

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
**D. INVOICE / BILL DETERMINATION**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

If the document is NOT payroll, share document, or bank statement, then it's either an INVOICE or BILL.
The distinction depends on WHO issued it and WHO must pay FROM {company_name}'S PERSPECTIVE.

üö®üö®üö® **ABSOLUTE CLASSIFICATION RULES - FOLLOW IN EXACT ORDER** üö®üö®üö®

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**RULE 1: CHECK "TO:" / "BILL TO:" / "CUSTOMER:" FIELD FIRST**

Look for these exact fields in the document:
- "TO:", "BILL TO:", "CUSTOMER:", "CLIENT:", "BUYER:", "RECEIVER:", "SOLD TO:", "SHIP TO:"

**Question: Does {company_name} (or its variations) appear in ANY of these fields?**

‚úÖ **YES** ‚Üí {company_name} is in the TO/BILL TO/CUSTOMER field
   
   **ABSOLUTE RULE:** 
   - {company_name} is the RECIPIENT/CUSTOMER
   - {company_name} MUST PAY this document
   - Another company issued this TO {company_name}
   
   **MANDATORY OUTPUT:**
   {{
     "document_type": "bill",
     "category": "money_going_out",
     "reasoning": "{company_name} appears in [TO/BILL TO/CUSTOMER] field. They are the recipient and must pay. This is a BILL."
   }}
   
   **‚õî STOP HERE. DO NOT CHECK OTHER RULES. OUTPUT IMMEDIATELY.**

‚ùå **NO** ‚Üí {company_name} is NOT in the TO/BILL TO/CUSTOMER field
   ‚Üí Continue to Rule 2

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**RULE 2: CHECK DOCUMENT HEADER/ISSUER**

Look at the TOP/HEADER section of the document for:
- Company name in largest font at top
- Company logo position (top left/center)
- Fields: "FROM:", "VENDOR:", "SELLER:", "SERVICE PROVIDER:"
- Company's tax/registration numbers in header
- Company's address/contact info at top

**Question: Does {company_name} (or its variations) appear as the ISSUER/HEADER?**

‚úÖ **YES** ‚Üí {company_name} is in the header as issuer
   
   **AND verify:** Is there ANOTHER company name in the TO:/CUSTOMER: field?
   
   ‚úÖ **YES** ‚Üí Different company in customer field
      
      **ABSOLUTE RULE:**
      - {company_name} ISSUED this document
      - {company_name} is REQUESTING payment
      - {company_name} will RECEIVE money
      
      **MANDATORY OUTPUT:**
      {{
        "document_type": "invoice",
        "category": "money_coming_in",
        "reasoning": "{company_name} issued this document to [customer name]. They are requesting payment. This is an INVOICE."
      }}
      
      **‚õî STOP HERE. OUTPUT IMMEDIATELY.**
   
   ‚ùå **NO** ‚Üí No other company in customer field or unclear
      ‚Üí Continue to Rule 3

‚ùå **NO** ‚Üí {company_name} is NOT the issuer
   ‚Üí Continue to Rule 3

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**RULE 3: CHECK BANK ACCOUNT OWNERSHIP**

Look at the PAYMENT DETAILS section (usually at bottom):
- "Pay to:", "Remit to:", "Payment details:", "Bank details:"
- Bank account holder name
- IBAN, Account number

**Question: Whose bank account is listed for payment?**

‚úÖ **Bank account belongs to {company_name}**
   ‚Üí {company_name} will RECEIVE the payment
   
   **MANDATORY OUTPUT:**
   {{
     "document_type": "invoice",
     "category": "money_coming_in",
     "reasoning": "Payment details show {company_name}'s bank account. They will receive payment. This is an INVOICE."
   }}
   
   **‚õî STOP HERE. OUTPUT IMMEDIATELY.**

‚úÖ **Bank account belongs to ANOTHER company** (not {company_name})
   ‚Üí {company_name} must PAY to that account
   
   **MANDATORY OUTPUT:**
   {{
     "document_type": "bill",
     "category": "money_going_out",
     "reasoning": "Payment details show [vendor name]'s bank account. {company_name} must pay to this account. This is a BILL."
   }}
   
   **‚õî STOP HERE. OUTPUT IMMEDIATELY.**

‚ùå **NO clear bank account or unclear**
   ‚Üí Continue to Rule 4

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**RULE 4: FINAL PAYMENT DIRECTION TEST**

Based on ALL available information, answer this question:

**"Will {company_name} SEND money or RECEIVE money in this transaction?"**

Analyze:
- Document layout and structure
- Company positions in the document
- Payment terms and conditions
- Any contextual clues

‚úÖ **{company_name} will SEND/PAY money**
   {{
     "document_type": "bill",
     "category": "money_going_out",
     "reasoning": "Based on document structure, {company_name} must pay. This is a BILL."
   }}

‚úÖ **{company_name} will RECEIVE/GET PAID money**
   {{
     "document_type": "invoice",
     "category": "money_coming_in",
     "reasoning": "Based on document structure, {company_name} will receive payment. This is an INVOICE."
   }}

‚ùå **Cannot determine payment direction**
   {{
     "document_type": null,
     "category": "illegible_document",
     "reasoning": "Cannot determine payment direction or document structure unclear."
   }}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üö® **CRITICAL VALIDATION BEFORE OUTPUT** üö®

Before generating final JSON, verify these ABSOLUTE RULES:

**FORBIDDEN COMBINATIONS - THESE ARE ALWAYS WRONG:**

‚ùå {company_name} in "BILL TO:" field + document_type = "invoice" ‚Üí **WRONG!** Must be "bill"
‚ùå {company_name} in "BILL TO:" field + category = "money_coming_in" ‚Üí **WRONG!** Must be "money_going_out"
‚ùå {company_name} in "CUSTOMER:" field + document_type = "invoice" ‚Üí **WRONG!** Must be "bill"
‚ùå document_type = "bill" + category = "money_coming_in" ‚Üí **WRONG!** Must be "money_going_out"
‚ùå document_type = "invoice" + category = "money_going_out" ‚Üí **WRONG!** Must be "money_coming_in"
‚ùå document_type = "payroll" + category = "money_coming_in" ‚Üí **WRONG!** Must be "money_going_out"
‚ùå document_type = "share_document" + category = "money_going_out" ‚Üí **WRONG!** Must be "money_coming_in"

**REQUIRED COMBINATIONS - THESE ARE ALWAYS CORRECT:**

‚úÖ document_type = "payroll" ‚Üí category MUST BE "money_going_out"
‚úÖ document_type = "invoice" ‚Üí category MUST BE "money_coming_in"
‚úÖ document_type = "bill" ‚Üí category MUST BE "money_going_out"
‚úÖ document_type = "share_document" ‚Üí category MUST BE "money_coming_in"
‚úÖ {company_name} in "BILL TO:" field ‚Üí MUST BE document_type = "bill" + category = "money_going_out"
‚úÖ {company_name} as issuer + other company in "BILL TO:" ‚Üí MUST BE document_type = "invoice" + category = "money_coming_in"

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**CLASSIFICATION EXAMPLES - STUDY THESE CAREFULLY**

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**Example 1: Clear BILL case**
Document header: "ABC Consulting Services Ltd"
BILL TO: Kyrastel Enterprises Limited
Amount: $500
Payment to: ABC Consulting's bank account

**Analysis:**
- Kyrastel appears in "BILL TO:" field ‚Üí **Rule 1 triggers**
- Kyrastel is the CUSTOMER/RECIPIENT
- Kyrastel must PAY ABC Consulting

**Output:**
{{
  "document_type": "bill",
  "category": "money_going_out",
  "company_name": "Kyrastel Enterprises Limited",
  "reasoning": "Kyrastel Enterprises Limited appears in BILL TO field. They are receiving this document from ABC Consulting and must pay. This is a BILL."
}}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**Example 2: Clear INVOICE case**
Document header: "Kyrastel Enterprises Limited"
BILL TO: XYZ Corporation
Amount: $1000
Payment to: Kyrastel's bank account

**Analysis:**
- Kyrastel in header as issuer ‚Üí **Rule 2 checks**
- XYZ Corporation in "BILL TO:" field (different company)
- Kyrastel's bank account for payment
- Kyrastel will RECEIVE money

**Output:**
{{
  "document_type": "invoice",
  "category": "money_coming_in",
  "company_name": "Kyrastel Enterprises Limited",
  "reasoning": "Kyrastel Enterprises Limited issued this document to XYZ Corporation. Payment goes to Kyrastel's bank account. They will receive payment. This is an INVOICE."
}}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**Example 3: Vendor invoice (BILL) case**
Document header: "N.A MechEnergy Consulting Engineer"
BILL TO: Kyrastel Enterprises ltd
Services: Engineering consultation
Payment to: N.A MechEnergy's bank account (IBAN: CY71...)

**Analysis:**
- Kyrastel in "BILL TO:" field ‚Üí **Rule 1 IMMEDIATELY triggers**
- N.A MechEnergy is the issuer/vendor
- Payment goes to N.A MechEnergy's account
- Kyrastel must PAY

**Output:**
{{
  "document_type": "bill",
  "category": "money_going_out",
  "company_name": "Kyrastel Enterprises Limited",
  "reasoning": "Kyrastel Enterprises ltd appears in BILL TO field. N.A MechEnergy issued this to Kyrastel. Payment goes to N.A MechEnergy's bank account. Kyrastel must pay. This is a BILL."
}}

**‚ö†Ô∏è WRONG Classification Example:**
{{
  "document_type": "invoice",
  "category": "money_coming_in",
  "reasoning": "...from the issuer's perspective, this is an invoice..."
}}
**Why this is WRONG:**
- ‚ùå Used issuer's perspective instead of {company_name}'s perspective
- ‚ùå Ignored Rule 1: {company_name} in BILL TO field
- ‚ùå Forbidden combination: company in BILL TO + invoice type

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**DOCUMENT TYPES:**
- "payroll": Payroll report with employee salary information ‚Üí money_going_out
- "share_document": Share/stock/equity documents ‚Üí money_coming_in
- "invoice": {company_name} issued it, requesting payment ‚Üí money_coming_in
- "bill": {company_name} received it, must pay vendor ‚Üí money_going_out
- "bank_statement": Bank statement ‚Üí bank_statement
- null: Illegible/cannot determine

**CATEGORIES:**
- "money_coming_in": {company_name} receives money (invoice, share_document)
- "money_going_out": {company_name} pays money (bill, payroll)
- "bank_statement": Bank statement
- "illegible_document": Cannot determine

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**REQUIRED JSON OUTPUT FORMAT:**
{{
  "document_type": "payroll|invoice|bill|bank_statement|share_document|null",
  "category": "money_coming_in|money_going_out|bank_statement|illegible_document",
  "company_name": "{company_name}",
  "total_amount": 1250.00,
  "confidence_score": 0.95,
  "reasoning": "Clear explanation from {company_name}'s perspective"
}}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**FINAL REMINDERS:**

1. ‚úÖ ALWAYS classify from {company_name}'s perspective
2. ‚úÖ Follow rules in EXACT order (Rule 1 ‚Üí Rule 2 ‚Üí Rule 3 ‚Üí Rule 4)
3. ‚úÖ STOP immediately when a rule gives a definitive answer
4. ‚úÖ If {company_name} in "BILL TO:" field ‚Üí ALWAYS bill + money_going_out
5. ‚úÖ Check forbidden combinations before outputting
6. ‚úÖ Payroll ‚Üí always money_going_out
7. ‚úÖ Invoice ‚Üí always money_coming_in
8. ‚úÖ Bill ‚Üí always money_going_out
9. ‚ùå NEVER use issuer's perspective
10. ‚ùå NEVER output explanatory text, only JSON
11. ‚ùå NEVER use markdown code blocks or backticks
12. ‚ùå NEVER add any text before or after the JSON object

Output pure JSON immediately. No formatting. No markdown. Just JSON."""

def generate_company_variations(company_name):
    """Generate common variations of company name for better matching"""
    variations = [company_name]
    
    # Remove common suffixes for matching
    suffixes = [
        ' Pvt Ltd', ' Private Limited', ' Pvt. Ltd.', ' Private Ltd',
        ' Ltd', ' Limited', ' LLC', ' Inc', ' Corp', ' Corporation',
        ' LLP', ' LP', ' PLC', ' Co.', ' Company', ' ENTERPRISES LIMITED',
        ' Enterprises Limited', ' ENTERPRISES LTD', ' Enterprises Ltd'
    ]
    
    name_without_suffix = company_name
    for suffix in suffixes:
        if company_name.upper().endswith(suffix.upper()):
            name_without_suffix = company_name[:len(company_name)-len(suffix)].strip()
            variations.append(name_without_suffix)
            break
    
    # Add common abbreviations
    if len(name_without_suffix.split()) > 1:
        words = name_without_suffix.split()
        acronym = ''.join([w[0].upper() for w in words if w])
        if len(acronym) > 1:
            variations.append(acronym)
    
    # Format variations as bullet list
    return '\n'.join([f"  - {var}" for var in set(variations)])

def clean_json_response(response_text):
    """
    Clean Claude's response to extract pure JSON
    Handles markdown code blocks, extra whitespace, and double braces
    """
    cleaned = response_text.strip()
    
    # Remove markdown code blocks (both ```json and ```)
    if cleaned.startswith("```"):
        # Find the first newline after the opening fence
        first_newline = cleaned.find('\n')
        if first_newline != -1:
            cleaned = cleaned[first_newline + 1:]
        else:
            # No newline found, remove the fence directly
            if cleaned.startswith("```json"):
                cleaned = cleaned[7:]
            elif cleaned.startswith("```"):
                cleaned = cleaned[3:]
    
    # Remove trailing code fence
    if cleaned.endswith("```"):
        cleaned = cleaned[:-3]
    
    # Remove double braces (sometimes Claude uses template syntax)
    cleaned = cleaned.replace("{{", "{").replace("}}", "}")
    
    # Strip again to remove any whitespace from fence removal
    cleaned = cleaned.strip()
    
    return cleaned

def download_from_s3(s3_key, bucket_name=None):
    """Download file from S3 using key"""
    try:
        if not bucket_name:
            bucket_name = os.getenv('S3_BUCKET_NAME', 'company-documents-2025')
        
        # Initialize S3 client
        aws_access_key = os.getenv('AWS_ACCESS_KEY_ID')
        aws_secret_key = os.getenv('AWS_SECRET_ACCESS_KEY')
        aws_region = os.getenv('AWS_REGION', 'eu-north-1')
        
        if aws_access_key and aws_secret_key:
            s3_client = boto3.client(
                's3',
                aws_access_key_id=aws_access_key,
                aws_secret_access_key=aws_secret_key,
                region_name=aws_region
            )
        else:
            s3_client = boto3.client('s3', region_name=aws_region)
        
        print(f"Downloading from bucket: {bucket_name}, key: {s3_key}")
        
        response = s3_client.get_object(Bucket=bucket_name, Key=s3_key)
        return response['Body'].read()
        
    except Exception as e:
        raise Exception(f"Error downloading from S3: {str(e)}")

def process_document_with_claude(pdf_content, company_name):
    """Process document with Claude and return classification"""
    try:
        # Initialize Anthropic client
        anthropic_client = anthropic.Anthropic(
            api_key=os.getenv('ANTHROPIC_API_KEY')
        )
        
        # Encode to base64
        pdf_base64 = base64.b64encode(pdf_content).decode('utf-8')
        
        # Get prompt
        prompt = get_classification_prompt(company_name)
        
        # Send to Claude
        message = anthropic_client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=2500,
            temperature=0,
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "document",
                            "source": {
                                "type": "base64",
                                "media_type": "application/pdf",
                                "data": pdf_base64
                            }
                        },
                        {
                            "type": "text",
                            "text": prompt
                        }
                    ]
                }
            ]
        )
        
        # Extract response
        response_text = message.content[0].text.strip()
        
        print(f"Token usage - Input: {message.usage.input_tokens}, Output: {message.usage.output_tokens}")
        
        return {
            "success": True,
            "classification": response_text,
            "token_usage": {
                "input_tokens": message.usage.input_tokens,
                "output_tokens": message.usage.output_tokens
            }
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }

def main(data):
    """
    Main function for document classification
    """
    try:
        # Validate required fields
        if 'company_name' not in data:
            return {
                "success": False,
                "error": "company_name is required"
            }
            
        if 's3_key' not in data:
            return {
                "success": False,
                "error": "s3_key is required"
            }
        
        company_name = data['company_name']
        s3_key = data['s3_key']
        bucket_name = data.get('bucket_name')
        
        print(f"Processing document for company: {company_name}, S3 key: {s3_key}")
        
        # Download PDF from S3
        pdf_content = download_from_s3(s3_key, bucket_name)
        print(f"Downloaded PDF, size: {len(pdf_content)} bytes")
        
        # Process with Claude
        result = process_document_with_claude(pdf_content, company_name)
        
        if result["success"]:
            try:
                # Parse Claude's JSON response with robust cleaning
                cleaned_response = clean_json_response(result["classification"])
                
                print(f"Cleaned response: {cleaned_response[:200]}...")  # Debug log
                
                classification_data = json.loads(cleaned_response)
                
                # CRITICAL: Post-processing validation and auto-correction
                validation_result = validate_and_correct_classification(
                    classification_data, 
                    company_name,
                    result["classification"]
                )
                
                if validation_result["corrected"]:
                    print(f"‚ö†Ô∏è AUTO-CORRECTED: {validation_result['correction_reason']}")
                    classification_data = validation_result["corrected_data"]
                
                if validation_result["warnings"]:
                    print(f"‚ö†Ô∏è Validation warnings: {validation_result['warnings']}")
                
                return {
                    "success": True,
                    "result": classification_data,
                    "metadata": {
                        "token_usage": result["token_usage"],
                        "s3_key": s3_key,
                        "company_name": company_name,
                        "validation": {
                            "corrected": validation_result["corrected"],
                            "correction_reason": validation_result.get("correction_reason"),
                            "warnings": validation_result.get("warnings")
                        }
                    }
                }
                
            except json.JSONDecodeError as e:
                return {
                    "success": False,
                    "error": f"Claude returned invalid JSON: {str(e)}",
                    "raw_response": result["classification"],
                    "cleaned_response": clean_json_response(result["classification"])
                }
        else:
            return {
                "success": False,
                "error": result["error"]
            }
            
    except Exception as e:
        print(f"Classification error: {str(e)}")
        return {
            "success": False,
            "error": f"Internal processing error: {str(e)}"
        }

def validate_and_correct_classification(classification_data, company_name, raw_response):
    """
    Validate classification and auto-correct obvious errors
    Returns dict with correction status and warnings
    """
    doc_type = classification_data.get("document_type")
    category = classification_data.get("category")
    reasoning = classification_data.get("reasoning", "").lower()
    
    corrected = False
    correction_reason = None
    warnings = []
    
    # CRITICAL CHECK 0: Payroll validation
    if doc_type == "payroll" and category != "money_going_out":
        classification_data["category"] = "money_going_out"
        classification_data["reasoning"] = "Auto-corrected: Payroll documents always represent money_going_out (company paying employees)"
        corrected = True
        correction_reason = "Payroll must be money_going_out"
    
    # Detect if reasoning mentions payroll but classified differently
    payroll_keywords = [
        "payroll", "salary register", "employee compensation", 
        "wage sheet", "salary analysis", "payroll report"
    ]
    
    is_payroll_in_reasoning = any(
        keyword in reasoning 
        for keyword in payroll_keywords
    )
    
    if is_payroll_in_reasoning and doc_type != "payroll":
        warnings.append("Reasoning mentions payroll but document type is not 'payroll'. Review recommended.")
    
    # CRITICAL CHECK 1: Detect reasoning contradictions
    # If reasoning says "must pay" or "customer" but classified as invoice
    customer_keywords = [
        "customer who must pay", f"{company_name.lower()}.*must pay", f"{company_name.lower()}.*customer",
        f"{company_name.lower()}.*receiver", f"{company_name.lower()}.*client", "receiving this invoice",
        f"{company_name.lower()}.*are the customer", "pay this invoice"
    ]
    
    is_customer_in_reasoning = any(
        re.search(pattern, reasoning, re.IGNORECASE) 
        for pattern in customer_keywords
    )
    
    if is_customer_in_reasoning and (doc_type == "invoice" or category == "money_coming_in"):
        # CRITICAL ERROR: Reasoning says customer but classified as invoice
        classification_data["document_type"] = "bill"
        classification_data["category"] = "money_going_out"
        classification_data["reasoning"] = (
            f"CORRECTED: {company_name} is the CUSTOMER/RECEIVER, "
            "therefore they must PAY. This is a bill, not an invoice."
        )
        corrected = True
        correction_reason = "Reasoning indicated customer role but was classified as invoice"
    
    # CRITICAL CHECK 2: Logical consistency rules
    if doc_type == "share_document" and category != "money_coming_in":
        classification_data["category"] = "money_coming_in"
        classification_data["reasoning"] = "Auto-corrected: Share documents always represent money_coming_in"
        corrected = True
        correction_reason = "Share document must be money_coming_in"
    
    if doc_type == "invoice" and category != "money_coming_in":
        classification_data["category"] = "money_coming_in"
        corrected = True
        correction_reason = "Invoice must be money_coming_in"
        warnings.append("Invoice was incorrectly categorized")
    
    if doc_type == "bill" and category != "money_going_out":
        classification_data["category"] = "money_going_out"
        corrected = True
        correction_reason = "Bill must be money_going_out"
        warnings.append("Bill was incorrectly categorized")
    
    # CRITICAL CHECK 3: Category-to-type consistency
    if category == "money_coming_in" and doc_type not in ["invoice", "share_document", "bank_statement"]:
        if doc_type == "bill":
            # This is a critical error - bill cannot be money_coming_in
            classification_data["category"] = "money_going_out"
            corrected = True
            correction_reason = "Bill cannot be money_coming_in, corrected to money_going_out"
        elif doc_type == "payroll":
            # CRITICAL: payroll can NEVER be money_coming_in
            classification_data["category"] = "money_going_out"
            corrected = True
            correction_reason = "Payroll can NEVER be money_coming_in"
        else:
            warnings.append(f"Inconsistent: category='money_coming_in' but document_type='{doc_type}'")
    
    if category == "money_going_out" and doc_type not in ["bill", "payroll", "bank_statement"]:
        if doc_type == "invoice":
            # Critical error - invoice cannot be money_going_out
            classification_data["category"] = "money_coming_in"
            corrected = True
            correction_reason = "Invoice cannot be money_going_out, corrected to money_coming_in"
        elif doc_type == "share_document":
            # CRITICAL: share_document can NEVER be money_going_out
            classification_data["category"] = "money_coming_in"
            corrected = True
            correction_reason = "Share document can NEVER be money_going_out"
        else:
            warnings.append(f"Inconsistent: category='money_going_out' but document_type='{doc_type}'")
    
    # Check confidence score
    confidence = classification_data.get("confidence_score", 1.0)
    if confidence < 0.6:
        warnings.append(f"Low confidence ({confidence}). Manual review recommended.")
    
    return {
        "corrected": corrected,
        "correction_reason": correction_reason,
        "warnings": " | ".join(warnings) if warnings else None,
        "corrected_data": classification_data if corrected else None
    }

def health_check():
    """Health check for the classification service"""
    try:
        required_vars = ['ANTHROPIC_API_KEY']
        missing_vars = [var for var in required_vars if not os.getenv(var)]
        
        if missing_vars:
            return {
                "healthy": False,
                "error": f"Missing environment variables: {', '.join(missing_vars)}"
            }
        
        return {
            "healthy": True,
            "service": "claude-document-classification",
            "version": "4.0-payroll-support",
            "supported_types": ["payroll", "invoice", "bill", "share_document", "bank_statement"],
            "anthropic_configured": bool(os.getenv('ANTHROPIC_API_KEY')),
            "aws_configured": bool(os.getenv('AWS_ACCESS_KEY_ID') and os.getenv('AWS_SECRET_ACCESS_KEY')),
            "s3_bucket": os.getenv('S3_BUCKET_NAME', 'company-documents-2025')
        }
        
    except Exception as e:
        return {
            "healthy": False,
            "error": str(e)
        }